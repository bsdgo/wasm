package parser

import (
	"bytes"
	"fmt"
	"github.com/sirupsen/logrus"
	"io"
	"io/ioutil"
	"sync"
	"wasm/utils"
)

const (
	ErrReadCount       = "Read count error"
	ErrReadSectionType = "Read section type error"
	ErrIncorrectOrder  = "Incorrect order for known section"

	ErrMagicNumber = "Magic number error"
	ErrVersion     = "Version number error"

	ErrInsufficientBytes = "Got insufficient bytes"
)

var (
	MagicNumber    = []byte{0x00, 0x61, 0x73, 0x6d}
	CurrentVersion = []byte{0x01, 0x00, 0x00, 0x00}
)

const (
	//section type
	st_unknown = iota
	st_type
	st_import
	st_functionDeclarations
	st_table
	st_memory
	st_global
	st_exceptionTypes
	st_export_
	st_start
	st_elem
	st_functionDefinitions
	st_data
	st_user
)

type decodeBody func(rd io.Reader, numbytes uint32) error

type Parser struct {
	Stream    io.Reader
	ChSection chan *Section
	ChErr     chan error
	ChQuit    chan struct{}
	WG        *sync.WaitGroup
	WGErr     *sync.WaitGroup
	HasErr    bool
}

type Section struct {
	Type            byte
	NumSectionBytes uint32
	Data            []byte
}

func New(filename string) (*Parser, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	return &Parser{
		Stream:    bytes.NewReader(content),
		ChSection: make(chan *Section),
		ChErr:     make(chan error),
		ChQuit:    make(chan struct{}),
		WG:        new(sync.WaitGroup),
		WGErr:     new(sync.WaitGroup),
		HasErr:    false,
	}, nil
}

func (p *Parser) Start() {
	go p.loop()
	var (
		bufType = make([]byte, 1)
		bufData []byte
	)
	// check magic number
	err := CheckConstant(p.Stream, MagicNumber, ErrMagicNumber)
	if err != nil {
		logrus.Error("CheckConstant: %s", err.Error())
		return
	}
	// check version
	err = CheckConstant(p.Stream, CurrentVersion, ErrVersion)
	if err != nil {
		logrus.Error("CheckConstant: %s", err.Error())
		return
	}

	// read loop
	// get section bytes,then send to loop()
	for !p.HasErr {
		// get section type,if read 0 byte, more => false
		_, err := p.Stream.Read(bufType)
		if err == io.EOF {
			logrus.Info("EOF")
			break
		} else if err != nil {
			p.HasErr = true
			p.WGErr.Add(1)
			p.ChErr <- err
			break
		}
		sectionType := bufType[0]
		logrus.Infof("section type: %d", sectionType)
		// get section num bytes
		sectionNumBytes, err := utils.DecodeUInt32(p.Stream)
		if err != nil {
			p.HasErr = true
			p.WGErr.Add(1)
			p.ChErr <- err
			break
		}
		logrus.Infof("section num bytes: %d", sectionNumBytes)

		// get section data
		bufData = make([]byte, sectionNumBytes)
		n, err := p.Stream.Read(bufData)
		if err != nil {
			p.HasErr = true
			p.WGErr.Add(1)
			p.ChErr <- err
			break
		}
		if uint32(n) != sectionNumBytes {
			p.HasErr = true
			p.WGErr.Add(1)
			p.ChErr <- fmt.Errorf(ErrInsufficientBytes)
			break
		}

		//make Section
		section := &Section{
			Type:            sectionType,
			NumSectionBytes: sectionNumBytes,
			Data:            bufData,
		}
		p.WG.Add(1)
		p.ChSection <- section
	}
	if !p.HasErr {
		p.WG.Wait()
	} else {
		p.WGErr.Wait()
	}
}

func (p *Parser) loop() {
	for {
		select {
		case err := <-p.ChErr:
			logrus.Errorf("loop(): error: %s", err.Error())
			p.WGErr.Done()
			return

		case section := <-p.ChSection:
			logrus.Infof("loop(): got section: %v", section)
			err := p.parseSection(section)
			if err != nil {
				p.HasErr = true
				p.WGErr.Add(1)
				p.ChErr <- err
			}else{

				p.WG.Done()
			}

		case <-p.ChQuit:
			logrus.Infof("loop(): quit.")
			return
		}
	}
}

func (p *Parser) parseSection(se *Section) error {
	//fmt.Println("parse section")
	return fmt.Errorf("parse error")
}

func (p *Parser) Stop() {
	close(p.ChQuit)
}

func CheckConstant(rd io.Reader, constant []byte, errMsg string) error {
	numBytes := len(constant)
	buf := make([]byte, numBytes)
	nRead, err := rd.Read(buf)
	if err != nil {
		return err
	}
	if nRead != numBytes {
		return fmt.Errorf(ErrReadCount)
	}
	for i := 0; i < numBytes; i++ {
		if buf[i] != constant[i] {
			return fmt.Errorf(errMsg)
		}
	}
	return nil
}

func loadSection(rd io.Reader, decodebody decodeBody) error {

	//step 1
	sectionBytes, err := utils.DecodeUInt32(rd)
	if err != nil {
		return err
	}
	//step 2
	decodebody(rd, sectionBytes)

	return nil
}

func LoadSections(rd io.Reader) error {
	var (
		buf             []byte
		lastSectionType byte
	)
	buf = make([]byte, 1)

	for {
		_, err := rd.Read(buf)
		if err != nil {
			return fmt.Errorf(ErrReadSectionType)
		}
		lastSectionType = st_unknown
		sectionType := buf[0]
		if sectionType != st_user {
			if sectionType > lastSectionType {
				lastSectionType = sectionType
			} else {
				return fmt.Errorf(ErrIncorrectOrder)
			}
		}
		switch sectionType {
		case st_type:
		case st_import:
		case st_functionDeclarations:
		case st_table:
		case st_memory:
		case st_global:
		case st_exceptionTypes:
		case st_export_:
		case st_start:
		case st_elem:
		case st_functionDefinitions:
		case st_data:
		case st_user:
		}

	}
}
